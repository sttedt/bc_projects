//함수
/*
    - 구조
        function 함수명 (타입 변수명, 타입 변수명, ...) options returns(타입 변수명 (생략가능), 타입 변수명,. ..){
            satement; ...
            return (...); <- 생략가능
        }
    - options
        1) 가시성   : (access modifier)
            - external : 컨트렉트상 명시된 것만 외부에 공개
            - public   : 모든 컨트렉트의 내부 외부에 공개
            - internal : 해당 컨트렉트와 상송 컨트렉트에만 공개
            - private  : 오직, 해당 컨트렉트만 공개
        2) 비용측면 : 
            - constant (더이상 사용되지 않는다 정의) -> 이렇게 정의된 함수는 gas를 소모하지 않는다.

            - view : 다음 행위를 함수 내부에서 하지 않겠다 <- 아래 코드를 해야하면 ciew 사용 불가
                1) 상태 변수 값 변경
                2) 이벤트 발생 (이벤트 -> 컨트렉트 -> nodejs쪽으로 이벤트 전달)
                3) 다른 컨트렉트 생성
                4) 이더 전송(송금)
                5) view나 pure로 선언되지 않은 함수 호출

            - pure :  다음 행위를 함수 내부에서 하지 않겠다 <- 아래 코드를 해야하면 pure 사용 불가
                1) 상태변수를 읽는다
                2) xx.balance 잔액확인등 접근시도
                3) 컨트렉트 사전에 이미 정의된 전역객체들 block, tx, msg등을 접근행위
                4) pure로 정의되어 있지 않는 함수를 호출
            - payable : 비용이 발생된다. 돈이 움직인다.
                ex) 컨트렉트가 맴버함수를 통해서 다른지갑(타인), 이더를 송금하거나 받는등 
                    -> 함수 자체가 지불가능한 형태가 되는 경우 사용

*/


// gas가 발생되지 않는 상황에서 상태젼수를 읽는다 => view ok

// 상태변수를 수정함으로 view 사용 불가 
//뭔가 많은 일을 했다....
// 상태변수를 사용 않했다. 지불관련 내용 없다.
// t4 함수를 구형하는데 부호없는 정수 2개를 입력받아서 더한 값을 리턴하는 함수를 구현하시오

// 리턴할 변수를 returns에서 미리 지정하면 변수 선언 및 retrun도 생략가능
// pure 함수 내부에서는 pure 함수만 호출할수 있다
// t(), t2() <-error

// 구현절차
// 상태변수

//생성자에서 상태변수를 초기화했다

// 컨트렉트 생성

// 조건문 반복문 제어문등
// 기본 문법은 기존 언어(자바, 자바스크립트등) 별반 다르지 않다

// 입력값이 1500 이상이면 1을 리턴
// 1500보다 작으면 -1 리턴
// 1500과 같으면 0리턴

// 삼항 연산자 => 상황이 2개, 값을 리턴 혹은 세팅 포인트
// 조건 ? 참일때값 : 거짓일때값

// 1부터 해당값까지의 누적합(총합)
// value 에 5를 넣으면, 1+2+3+4+5 => 15
// 이런 부분 구현하시오


// forCheck2를 구현, 누적합, 누적곱을 구해서 리턴

// 형변환

// 1. 암묵적 형변환 : 작은 타입 -> 큰타입 , uint8 -> uint256
// 2. 명시적 형변환 : 큰타입 -> 작은 타입, uint256 -> uint8 (데이터를 자르고, 자료형고정)

// 복합타입 : 배열, 구조체, 문자열, 이벤트,...

// 배열 선언 및 초기화의 사이즈 생략

// 함수, memory 키워드 사용

// memory 변수는 명식적으로 memory 키워드를 사용해야 한다.
// 함수 호출시 내부에만 존재하는 임시변수
// storage 변수 대비 저렴하다.(싸다, 비용이 들지 않는다)
// 상태변수를 지역변수에 대입하는 행위

//상태변수를 memory 변수에 넣고 memory 변수를 수정하면,
// 상태변수에 영향을 미치지 않는다. 왜 상태변수 값이
// 카피되기 때문에 상태변수는 보전된다.

// 바이트 배열
// byte, bytes 

// bytes : 정적 바이트 배열, 선언시 고정크기를 가진다

// 사이즈 overfull -> error


// 바이트 배열을 동적으로 구성하여, 사이즈 넘었을때 사용하면
// 유동적으로 조절이 된다. -> gas 발생, 고정크기를 권장

// 동적생성된 변수는 리턴불가

// 문자열, 아직 컴파일러가 발전하는 단계 이므로,
// 우리가 편히 사용했던 라이브러리가 많이 없다.
// 일일이 만들어 줘야한다.

// 문자열 기초 라이브러리 만들기
// byte[] -> string

// 입력한 byte 배열의 크기만큼 bytes의 크기를 잡아준다
// 인덱스 별로 카피

// 문자열 변환, 모든데이터는 bytes에 담겼으므로, string 변환

// 문자열 더하기
// addString
// input  :  string, string ->
// output : string
// 입력된 문자열을 이어 붙여서 리턴하는 함수
// 문자열을 bytes 변환하여 2개 합한 크기로 버퍼를 만들어서 차례대로 복사후
// 문자열화 시키면

// 문자열 자르기
// subString()
// input  : string, offset(시작위치), len(길이)
// output : string , 

//  정상적으로 자를수 있다 ( 단, 한글은 배제 , 바이트수가 달라서 방식이 다름)
// 자른 문자열이 들어갈 버퍼 생성

// Mapping : 자바(Map), 파이썬(딕셔너리), JS(객체)
// 키 :  값
// 키 : 모든 자료형이 올수 있다.
// public getter 함수를 자동으로 만들어준다.

// 구조체

// - 사용자 정의 타입
// - 어떤 타입의 변수도 맴버로 담을 수 있다.
// - 매핑 형태의 키로는 사용이 불가
// - 구조체는 스토리지에 저장된다 -> 상태변수로만 존재
// - 자기참조 => depth 제한
// - 구조체 배열은 3번, 매핑값으로 대체하는 방식은 2번까지만 허용